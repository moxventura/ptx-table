<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="03P$G`~QrjrPwf?=REtY" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="24N8xf|DYs^qwa3ExAj!"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace table {" line1="" line2="    /**" line3="     * Creates a Table with the given amount of `rows` and `cols`" line4="     * @param rows the number of rows" line5="     * @param cols the number of columns" line6="     * @param defaultValue the default value for the matrix" line7="     */" line8="    //% block=&quot;Table with $rows rows and $cols cols|| default value $defaultValue&quot;" line9="    //% rows.min=1 rows.defl=5" line10="    //% cols.min=1 cols.defl=5" line11="    //% expandableArgumentMode=&quot;toggle&quot;" line12="    //% defaultValue.defl=0" line13="    //% group=&quot;Create&quot;" line14="    export function createTable(cols: number, rows: number, defaultValue?: number): number[][] {" line15="        if (rows &lt; 1 || cols &lt; 1) return undefined;" line16="        let table: number[][] = [];" line17="        for (let i = 0; i &lt; rows; i++) {" line18="            table[i] = [];" line19="            for (let j = 0; j &lt; cols; j++) {" line20="                table[i][j] = defaultValue;" line21="            }" line22="        }" line23="        return table;" line24="    }" line25="" line26="    const directions = [" line27="        [1, 0],   // right" line28="        [0, 1],   // down" line29="        [-1, 0],  // left" line30="        [0, -1]   // up" line31="    ];" line32="" line33="    function carvePathIterative(maze: number[][], startX: number, startY: number) {" line34="        const stack = [[startX, startY]]; // Initialize the stack with the starting position" line35="        maze[startY][startX] = 0; // Mark the starting cell as a path" line36="" line37="        while (stack.length &gt; 0) {" line38="            const [x, y] = stack.pop(); // Get the current cell" line39="" line40="            const directions2 = [" line41="                [1, 0],   // right" line42="                [0, 1],   // down" line43="                [-1, 0],  // left" line44="                [0, -1]   // up" line45="            ];" line46="            const shuffledDirections = directions2.sort(() =&gt; Math.random() - 0.5); // Randomize directions" line47="" line48="            for (let chosenDirection of shuffledDirections) {" line49="                const chooseX = x + chosenDirection[0] * 2; // Move two steps in the x direction" line50="                const chooseY = y + chosenDirection[1] * 2; // Move two steps in the y direction" line51="" line52="                // Check if the new position is within bounds and is a wall" line53="                if (chooseX &gt;= 0 &amp;&amp; chooseX &lt; maze[0].length &amp;&amp; chooseY &gt;= 0 &amp;&amp; chooseY &lt; maze.length &amp;&amp; maze[chooseY][chooseX] === 1) {" line54="                    maze[y + chosenDirection[1]][x + chosenDirection[0]] = 0; // Remove the wall between the cells" line55="                    maze[chooseY][chooseX] = 0; // Mark the new cell as a path" line56="                    stack.push([chooseX, chooseY]); // Push the new cell onto the stack" line57="                }" line58="            }" line59="        }" line60="    }" line61="" line62="" line63="    /**" line64="     * Creates a Maze with the given amount of `rows` and `cols`" line65="     * @param rows the number of rows" line66="     * @param cols the number of columns" line67="     */" line68="    //% block=&quot;Maze table with $rows rows and $cols cols&quot;" line69="    //% rows.min=1 rows.defl=21" line70="    //% cols.min=1 cols.defl=21" line71="    //% group=&quot;Create&quot;" line72="    export function createMaze(cols: number, rows: number) {" line73="        const maze = table.createTable(cols, rows, 1);" line74="        carvePathIterative(maze, 0, 0);" line75="        return maze;" line76="    }" line77="" line78="    /**" line79="     * Sets a value in the table or does nothing if the location does not exist" line80="     * @param row the row number of the value to set" line81="     * @param col the column number of the value to set" line82="     */" line83="    //% block=&quot;in table $table| set value at row $row col $col| to $value&quot;" line84="    //% row.min=0" line85="    //% col.min=0" line86="    //% group=&quot;Access&quot;" line87="    export function setValue(table: number[][], col: number, row: number, value: number): void {" line88="        if (table[row] &amp;&amp; table[row][col] !== undefined) {" line89="            table[row][col] = value;" line90="        }" line91="    }" line92="" line93="    /**" line94="     * Gets a value from the table or `undefined` if the given cell does not exist" line95="     * @param table the table to get the value from" line96="     * @param row the row number" line97="     * @param col the column number" line98="     */" line99="    //% block=&quot;from table $table| get value at row $row| col $col&quot;" line100="    //% row.min=0" line101="    //% col.min=0" line102="    //% group=&quot;Access&quot;" line103="    export function getValue(table: number[][], col: number, row: number): number {" line104="        if (table[row] &amp;&amp; table[row][col] !== undefined) {" line105="            return table[row][col];" line106="        }" line107="        return undefined;" line108="    }" line109="" line110="    /**" line111="     * Writes the table to the led." line112="     * Optionally give the `row` and `col` of the cell to start drawing." line113="     * The starting cell would come in the top left corner" line114="     */" line115="    //% block=&quot;Write $table| to led|| starting from row $row and col $col or else $defaultValue&quot;" line116="    //% expandableArgumentMode=&quot;toggle&quot;" line117="    //% row.min=0 row.defl=0" line118="    //% col.min=0 col.defl=0" line119="    //% group=&quot;Operations&quot;" line120="    export function plot(table: number[][], col: number, row: number, defaultValue: number) {" line121="        for (let k = 0; k &lt; 5; k++) {" line122="            for (let l = 0; l &lt; 5; l++) {" line123="                let value = getValue(table, row + k, col + l);" line124="                if (value == undefined) {" line125="                    value = defaultValue;" line126="                }" line127="                if (value &amp;&amp; value != 0) {" line128="                    led.plot(k, l);" line129="                }" line130="                else {" line131="                    led.unplot(k, l);" line132="                }" line133="            }" line134="        }" line135="    }" line136="" line137="    /**" line138="    * Writes the table to the led. Starting at the given `row` and `col` on the led-grid" line139="    * Optionally give the `row` and `col` of the cell of the table to start drawing." line140="    * The defaultValue will fill the rest of the grid" line141="    */" line142="    //% block=&quot;Write $table| to led starting at row $gridRow and col $gridCol| selecting row $row and col $col from table or else $defaultValue&quot;" line143="    //% expandableArgumentMode=&quot;toggle&quot;" line144="    //% gridRow.min=0 gridRow.max=4 gridRow.defl=0" line145="    //% gridCol.min=0 gridcol.max=4 gridCol.defl=0" line146="    //% row.min=0 row.defl=0" line147="    //% col.min=0 col.defl=0" line148="    //% group=&quot;Operations&quot;" line149="    export function plotAt(table: number[][], gridCol: number, gridRow: number, col: number = 0, row: number = 0, defaultValue: number = 0) {" line150="        if (gridRow &lt; 0 ||" line151="            gridCol &lt; 0 ||" line152="            gridRow &gt; 4 ||" line153="            gridCol &gt; 4) return;" line154="        for (let m = 0; m &lt; 5; m++) {" line155="            for (let n = 0; n &lt; 5; n++) {" line156="                let plotAtValue = defaultValue;" line157="                if (m &gt;= gridRow &amp;&amp; n &gt;= gridCol) {" line158="                    plotAtValue = getValue(table, col + m - gridCol, row + n - gridRow);" line159="                }" line160="                if (plotAtValue == undefined) {" line161="                    plotAtValue = defaultValue;" line162="                }" line163="                if (plotAtValue &amp;&amp; plotAtValue != 0) {" line164="                    led.plot(m, n);" line165="                }" line166="                else {" line167="                    led.unplot(m, n);" line168="                }" line169="            }" line170="        }" line171="    }" line172="}" numlines="173"></mutation></block></statement></block></xml>